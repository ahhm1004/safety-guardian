"""
행동 패턴 분석 시스템 메인 모듈

모든 모듈을 통합하여 전체 파이프라인을 실행합니다.
"""

import os
import sys
import time
import logging
import argparse
from pathlib import Path
import cv2
import threading
import signal  # 시그널 모듈 추가
import numpy as np

# 모듈 임포트
from modules.video_input.video_loader import create_video_loader
from modules.object_detection.detector import create_detector
from modules.pose_estimation.pose_estimator import create_pose_estimator
from modules.action_recognition.action_recognizer import create_action_recognizer
from modules.visualization.visualizer import Visualizer
from utils.s3_utils import download_model
from config import (
    SYSTEM_CONFIG, ALERT_CONFIG, VIDEO_CONFIG, VISUALIZATION_CONFIG,
    DETECTION_CONFIG, POSE_CONFIG, ACTION_CONFIG, DANGER_ZONE_CONFIG
)

# 로깅 설정
logging.basicConfig(
    level=getattr(logging, SYSTEM_CONFIG['log_level']),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(SYSTEM_CONFIG['log_file']),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class BehaviorAnalysisSystem:
    """행동 패턴 분석 시스템 통합 클래스"""
    
    def __init__(self):
        """시스템 초기화"""
        self.video_loader = None
        self.detector = None
        self.pose_estimator = None
        self.action_recognizer = None
        self.visualizer = None
        self.alert_manager = None
        
        # 알림 설정
        self.alert_actions = ALERT_CONFIG['alert_actions']
        self.min_consecutive_frames = ALERT_CONFIG['min_consecutive_frames']
        self.alert_enabled = ALERT_CONFIG['enabled']
        
        # 알림 추적용 변수
        self.alert_counts = {}              # 각 행동 연속 발생 프레임 수
        self.last_alert_time = {}           # 행동별/구역별 마지막 알림 시간
        self.method_last_alert_time = {     # 알림 방법별 마지막 알림 시간
            'console': {},                  # {행동/구역키: 마지막 시간}
            'file': {},
            'email': {},
            'api': {},
            'image': {}
        }
        
        # 실행 상태 플래그 추가
        self.running = True
        
        # 성능 최적화 설정
        self.frame_resize_factor = SYSTEM_CONFIG.get('frame_resize_factor', 1.0)
        
    def initialize(self):
        """
        모든 모듈 초기화
        
        Returns:
            bool: 초기화 성공 여부
        """
        # 필요한 디렉토리 생성
        os.makedirs('models', exist_ok=True)
        os.makedirs('data', exist_ok=True)
        os.makedirs('results', exist_ok=True)
        os.makedirs('logs', exist_ok=True)
        
        # 알림 로그 파일 디렉토리 생성
        if 'file' in ALERT_CONFIG['alert_methods']:
            alert_file_path = ALERT_CONFIG['alert_file']
            alert_dir = os.path.dirname(alert_file_path)
            if alert_dir:
                os.makedirs(alert_dir, exist_ok=True)
                logger.info(f"알림 로그 디렉토리 확인 및 생성: {alert_dir}")
                
            # 알림 파일이 없으면 빈 파일 생성
            if not os.path.exists(alert_file_path):
                try:
                    # 빈 파일 생성
                    with open(alert_file_path, 'w') as f:
                        pass
                    logger.info(f"알림 로그 파일 생성: {alert_file_path}")
                except Exception as e:
                    logger.warning(f"알림 로그 파일 생성 실패: {e}, 첫 알림 발생 시 자동 생성됩니다.")
        
        # 알림 이미지 저장 디렉토리 생성
        self.alert_image_dir = os.path.join('results', 'alert_images')
        os.makedirs(self.alert_image_dir, exist_ok=True)
        logger.info(f"알림 이미지 디렉토리 확인 및 생성: {self.alert_image_dir}")
        
        # 모델 다운로드
        self._download_models()
        
        # 비디오 로더 생성
        self.video_loader = create_video_loader()
        if not self.video_loader:
            logger.error("비디오 로더 생성 실패")
            return False
            
        # 객체 검출기 생성
        self.detector = create_detector()
        if not self.detector:
            logger.error("객체 검출기 생성 실패")
            return False
            
        # 자세 추정기 생성
        self.pose_estimator = create_pose_estimator()
        if not self.pose_estimator:
            logger.error("자세 추정기 생성 실패")
            return False
            
        # 행동 인식기 생성
        self.action_recognizer = create_action_recognizer()
        if not self.action_recognizer:
            logger.error("행동 인식기 생성 실패")
            return False
            
        # 시각화 모듈 생성
        self.visualizer = Visualizer()
        
        # 모델 로드
        logger.info("모델 로드 중...")
        
        if not self.detector.load_model():
            logger.error("객체 검출 모델 로드 실패")
            return False
            
        if not self.pose_estimator.load_model():
            logger.error("자세 추정 모델 로드 실패")
            return False
            
        if not self.action_recognizer.load_model():
            logger.error("행동 인식 모델 로드 실패")
            return False
            
        logger.info("시스템 초기화 완료")
        return True
        
    def _download_models(self):
        """필요한 모델 파일 다운로드"""
        # 다운로드할 모델 목록
        models_to_download = []
        
        # YOLO 모델
        if not os.path.exists(DETECTION_CONFIG['model_path']):
            models_to_download.append(os.path.basename(DETECTION_CONFIG['model_path']))
            
        # 자세 추정 모델 (Mediapipe는 내장 모델이므로 다운로드 불필요)
        if POSE_CONFIG['model_type'] != 'mediapipe' and not os.path.exists(POSE_CONFIG['model_path']):
            models_to_download.append(os.path.basename(POSE_CONFIG['model_path']))
            
        # 행동 인식 모델 (규칙 기반은 모델 불필요)
        if ACTION_CONFIG['model_type'] != 'rule' and not os.path.exists(ACTION_CONFIG['model_path']):
            models_to_download.append(os.path.basename(ACTION_CONFIG['model_path']))
            
        # 모델 다운로드
        for model_name in models_to_download:
            logger.info(f"모델 다운로드 중: {model_name}")
            download_model(model_name)
            
    def process_video(self):
        """비디오 처리 메인 루프"""
        # 멀티스레딩 설정
        enable_threading = SYSTEM_CONFIG.get('enable_threading', False)
        
        # 비디오 소스 열기
        if not self.video_loader.open():
            logger.error("비디오 소스를 열 수 없습니다.")
            return
            
        frame_size = self.video_loader.frame_size
        fps = self.video_loader.fps
        
        # 프레임 크기 축소 적용 (설정된 경우)
        if self.frame_resize_factor != 1.0:
            new_width = int(frame_size[0] * self.frame_resize_factor)
            new_height = int(frame_size[1] * self.frame_resize_factor)
            logger.info(f"프레임 크기 조정: {frame_size} -> ({new_width}, {new_height})")
        
        # 비디오 저장 설정
        self.visualizer.setup_video_writer(frame_size, fps)
        
        logger.info(f"비디오 처리 시작, 크기: {frame_size}, FPS: {fps}")
        logger.info(f"현재 설정 - skip_frames: {VIDEO_CONFIG['skip_frames']}, performance_mode: {VIDEO_CONFIG['performance_mode']}")
        logger.info(f"탐지 설정 - confidence_threshold: {DETECTION_CONFIG['confidence_threshold']}, model_size: {DETECTION_CONFIG['model_size']}")
        
        frame_count = 0
        process_time = time.time()
        
        # FPS 조절을 위한 변수 추가
        target_fps = SYSTEM_CONFIG.get('target_fps', 30)  # 목표 FPS (기본값 30)
        frame_time = 1.0 / max(1, target_fps)  # 프레임당 시간 (초)
        next_frame_time = time.time()
        
        # 디버깅을 위한 변수 추가
        detection_count = 0  # 성공적인 객체 탐지 수
        action_count = 0     # 성공적인 행동 인식 수
        
        # 결과 저장용 변수
        last_results = {
            'frame': None,
            'detections': [],
            'poses': [],
            'actions': [],
            'danger_violations': []
        }
        
        # 스레드 관리
        analysis_thread = None
        analysis_result = None
        
        # 분석 함수 (스레드로 실행)
        def analyze_frame(frame, current_frame_count):
            # 프레임 크기 조정 (성능 향상용)
            if self.frame_resize_factor != 1.0:
                new_width = int(frame.shape[1] * self.frame_resize_factor)
                new_height = int(frame.shape[0] * self.frame_resize_factor)
                
                # 크기 변경된 프레임으로 분석
                resized_frame = cv2.resize(frame, (new_width, new_height))
                
                # 객체(사람) 검출
                detections = self.detector.detect(resized_frame)
                
                # 크기 조정 비율에 맞게 바운딩 박스 좌표 조정
                for i in range(len(detections)):
                    # x1, y1, x2, y2, confidence, class_id 형식
                    detections[i][0] = detections[i][0] / self.frame_resize_factor  # x1
                    detections[i][1] = detections[i][1] / self.frame_resize_factor  # y1
                    detections[i][2] = detections[i][2] / self.frame_resize_factor  # x2
                    detections[i][3] = detections[i][3] / self.frame_resize_factor  # y2
            else:
                # 원본 크기로 분석
                detections = self.detector.detect(frame)
                
            # 검출된 객체가 없으면 빈 결과 반환
            if len(detections) == 0:
                return {
                    'detections': [],
                    'poses': [],
                    'actions': [],
                    'danger_violations': []
                }
                
            # 각 검출 객체에 대해 자세 추정 및 행동 인식 수행
            poses = []
            actions = []
            danger_violations = []
            
            for detection in detections:
                # 바운딩 박스 추출
                bbox = detection[:4]
                
                # 신뢰도가 임계값보다 낮으면 건너뛰기
                confidence = detection[4]
                class_id = int(detection[5]) if len(detection) > 5 else 0
                
                if confidence < DETECTION_CONFIG.get('confidence_threshold', 0.5):
                    continue
                
                # 자세 추정
                pose = self.pose_estimator.estimate_pose(frame, bbox)
                if pose is None:
                    pose = {'keypoints': [], 'connections': [], 'bbox': bbox, 'confidence': 0, 'class_id': class_id}
                else:
                    # 클래스 ID 추가
                    pose['class_id'] = class_id
                    
                # 행동 인식
                action = self.action_recognizer.recognize(pose)
                
                # 객체 클래스 정보 추가
                action['class_id'] = class_id
                
                # 위험 구역 침범 감지
                danger_violation = self.action_recognizer.detect_danger_zone_violation(pose)
                
                poses.append(pose)
                actions.append(action)
                danger_violations.append(danger_violation)
                
                # 알림 처리
                if self.alert_enabled:
                    self._handle_alert(action, danger_violation, frame)
            
            return {
                'detections': detections,
                'poses': poses,
                'actions': actions,
                'danger_violations': danger_violations
            }
        
        # 프레임 처리 루프
        self.running = True  # 실행 상태 플래그 초기화
        while self.running:  # running 대신 self.running 사용
            loop_start_time = time.time()
            
            # 프레임 읽기
            ret, frame = self.video_loader.read_frame()
            if not ret:
                break
                
            frame_count += 1
            
            # 분석할 프레임 선택 (프레임 건너뛰기로 성능 최적화)
            analyze_current_frame = frame_count % VIDEO_CONFIG['skip_frames'] == 0
            
            if analyze_current_frame:
                if enable_threading and analysis_thread is None:
                    # 이전 분석 결과가 있으면 사용
                    if analysis_result is not None:
                        last_results.update(analysis_result)
                        analysis_result = None
                    
                    # 새 프레임 분석 시작 (스레드로) - frame_count 전달
                    analysis_thread = threading.Thread(
                        target=lambda: setattr(self, '_temp_result', analyze_frame(frame.copy(), frame_count))
                    )
                    analysis_thread.start()
                elif not enable_threading:
                    # 스레딩 없이 직접 분석 - frame_count 전달
                    analysis_result = analyze_frame(frame, frame_count)
                    last_results.update(analysis_result)
                    
                    # 디버깅용: 탐지 및 행동 개수 확인
                    if len(analysis_result.get('detections', [])) > 0:
                        detection_count += 1
                    if len(analysis_result.get('actions', [])) > 0:
                        action_count += 1
            
            # 스레드가 완료되었는지 확인
            if enable_threading and analysis_thread is not None:
                if not analysis_thread.is_alive():
                    # 결과 가져오기
                    if hasattr(self, '_temp_result'):
                        analysis_result = self._temp_result
                        delattr(self, '_temp_result')
                    
                    analysis_thread = None
            
            # 마지막 분석 결과로 시각화
            last_results['frame'] = frame
            
            # 시각화 전 데이터 검증
            detections = last_results.get('detections', [])
            poses = last_results.get('poses', [])
            actions = last_results.get('actions', [])
            danger_violations = last_results.get('danger_violations', [])
            
            # detections 데이터 검증 및 필터링
            validated_detections = []
            for det in detections:
                # 올바른 형식의 detection인지 확인 (x1, y1, x2, y2, confidence, class_id)
                if det is None or not isinstance(det, (list, tuple)) or len(det) < 4:
                    continue
                    
                # 바운딩 박스 좌표가 정수형인지 확인
                try:
                    # 데이터 복사 및 변환
                    validated_det = det.copy() if isinstance(det, list) else list(det)
                    
                    # 좌표값만 정수로 변환 (나머지는 원래 형식 유지)
                    for i in range(4):
                        if i < len(validated_det):
                            validated_det[i] = int(validated_det[i])
                            
                    validated_detections.append(validated_det)
                except (TypeError, ValueError) as e:
                    logger.warning(f"검출 데이터 변환 중 오류: {e}, 데이터: {det}")
                    continue
            
            # 데이터 검증 결과 로깅 - 빈도 줄이고 로그 내용 최소화
            if frame_count % 100 == 0:  # 30에서 100으로 변경
                # 로그 메시지 삭제
                pass
            
            # 유효한 탐지 데이터가 없는 경우 원본 detections 사용
            if len(validated_detections) == 0 and isinstance(detections, np.ndarray) and detections.size > 0:
                validated_detections = detections.tolist() if isinstance(detections, np.ndarray) else detections
            
            # VISUALIZATION_CONFIG에서 텍스트 표시 설정 확인 및 강제 활성화
            if 'show_labels' in VISUALIZATION_CONFIG:
                VISUALIZATION_CONFIG['show_labels'] = True
            if 'show_confidence' in VISUALIZATION_CONFIG:    
                VISUALIZATION_CONFIG['show_confidence'] = True
            if 'show_action_label' in VISUALIZATION_CONFIG:
                VISUALIZATION_CONFIG['show_action_label'] = True
            if 'show_bbox' in VISUALIZATION_CONFIG:
                VISUALIZATION_CONFIG['show_bbox'] = True
            
            # Visualizer 인스턴스의 설정도 직접 업데이트
            self.visualizer.show_bbox = True
            self.visualizer.show_action_label = True
            self.visualizer.show_skeleton = VISUALIZATION_CONFIG.get('show_skeleton', True)
            
            # 시각화 설정 상태 로깅 - 빈도 증가하여 300으로 변경 (덜 자주 출력)
            if frame_count % 300 == 0:
                logger.info(f"시각화 설정 상태 - bbox: {VISUALIZATION_CONFIG.get('show_bbox', 'N/A')}, action_label: {VISUALIZATION_CONFIG.get('show_action_label', 'N/A')}")
            
            # 시각화 및 키 입력 처리
            output_frame, key = self.visualizer.visualize_frame(
                frame, 
                validated_detections,  # 검증된 detections 사용 
                poses, 
                actions,
                danger_violations
            )
            
            # ESC 키로 종료
            if key == 27:  # ESC 키
                logger.info("사용자에 의해 분석이 중단되었습니다.")
                self.running = False  # running 대신 self.running 사용
                break
            
            # 중간 과정 로깅
            if frame_count % 100 == 0:
                elapsed = time.time() - process_time
                fps_actual = 100 / max(0.001, elapsed)
                # 로그 메시지 삭제
                process_time = time.time()
                
            # FPS 조절을 위한 지연 시간 계산 및 적용
            elapsed_loop_time = time.time() - loop_start_time
            if elapsed_loop_time < frame_time:
                # 프레임 처리가 목표 FPS보다 빠르면 지연 시간 추가
                sleep_time = frame_time - elapsed_loop_time
                time.sleep(sleep_time)
            
            # 다음 프레임 처리 시작 시간 계산
            next_frame_time = max(next_frame_time + frame_time, time.time())
                
        # 자원 해제
        self.video_loader.release()
        self.visualizer.release()
        
        if enable_threading and analysis_thread is not None and analysis_thread.is_alive():
            analysis_thread.join(timeout=1.0)
        
        logger.info(f"비디오 처리 완료, 총 프레임: {frame_count}")
        
    def _handle_alert(self, action, danger_violation=None, current_frame=None):
        """
        알림 처리
        
        Args:
            action (dict): 행동 분류 결과
            danger_violation (dict, optional): 위험 구역 침범 정보
            current_frame (numpy.ndarray, optional): 현재 비디오 프레임
        """
        action_label = action['action']
        
        # 관심 행동이 아니면 카운트 초기화 후 리턴
        if action_label not in self.alert_actions:
            self.alert_counts[action_label] = 0
            
        # 행동 카운트 증가
        self.alert_counts[action_label] = self.alert_counts.get(action_label, 0) + 1
        
        # 알림 발생 조건 체크 (행동 기반)
        if self.alert_counts[action_label] >= self.min_consecutive_frames:
            # 마지막 알림 시간 확인 (쿨다운)
            now = time.time()
            last_time = self.last_alert_time.get(action_label, 0)
            
            if now - last_time >= ALERT_CONFIG['cooldown_seconds']:
                self._send_custom_alert(
                    f"[경고] {action_label} 행동 감지됨 (신뢰도: {action['confidence']:.2f})",
                    alert_type='action',
                    action_type=action_label,
                    frame=current_frame
                )
                self.last_alert_time[action_label] = now
                self.alert_counts[action_label] = 0
        
        # 위험 구역 침범 알림 처리
        if danger_violation and danger_violation['violated']:
            zone_idx = danger_violation['zone_index']
            alert_key = f"danger_zone_{zone_idx}"
            
            # 마지막 알림 시간 확인 (쿨다운)
            now = time.time()
            last_time = self.last_alert_time.get(alert_key, 0)
            
            if now - last_time >= ALERT_CONFIG['cooldown_seconds']:
                alert_msg = f"[경고] {DANGER_ZONE_CONFIG['alert_message']} (구역: {zone_idx+1})"
                self._send_custom_alert(
                    alert_msg,
                    alert_type='danger_zone',
                    zone_idx=zone_idx,
                    frame=current_frame
                )
                self.last_alert_time[alert_key] = now
    
    def _send_custom_alert(self, alert_msg, alert_type=None, action_type=None, zone_idx=None, frame=None):
        """
        사용자 정의 알림 전송
        
        Args:
            alert_msg (str): 알림 메시지
            alert_type (str, optional): 알림 유형 ('action', 'danger_zone')
            action_type (str, optional): 행동 유형
            zone_idx (int, optional): 위험 구역 인덱스
            frame (numpy.ndarray, optional): 현재 비디오 프레임
        """
        # 현재 시간과 알림 키 생성
        now = time.time()
        timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')
        
        # 알림 키 생성 (행동 유형 또는 위험 구역 인덱스)
        if alert_type == 'action':
            alert_key = action_type
        elif alert_type == 'danger_zone':
            alert_key = f"danger_zone_{zone_idx}"
        else:
            alert_key = 'unknown'
            
        # 글로벌 로깅 (항상 기록)
        logger.warning(alert_msg)
        
        # 방법별 쿨다운 설정과 적용
        method_cooldowns = ALERT_CONFIG.get('method_cooldowns', {})
        
        # 콘솔 알림
        if 'console' in ALERT_CONFIG['alert_methods']:
            method_key = 'console'
            cooldown = method_cooldowns.get(method_key, ALERT_CONFIG['cooldown_seconds'])
            last_time = self.method_last_alert_time[method_key].get(alert_key, 0)
            
            if now - last_time >= cooldown:
                print(f"\033[91m{alert_msg}\033[0m")  # 빨간색으로 출력
                self.method_last_alert_time[method_key][alert_key] = now
            
        # 파일 알림
        if 'file' in ALERT_CONFIG['alert_methods']:
            method_key = 'file'
            cooldown = method_cooldowns.get(method_key, ALERT_CONFIG['cooldown_seconds'])
            last_time = self.method_last_alert_time[method_key].get(alert_key, 0)
            
            if now - last_time >= cooldown:
                try:
                    with open(ALERT_CONFIG['alert_file'], 'a') as f:
                        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {alert_msg}\n")
                    self.method_last_alert_time[method_key][alert_key] = now
                except Exception as e:
                    logger.error(f"알림 로그 파일 기록 실패: {e}")
        
        # 이미지 캡처 및 저장
        if frame is not None:
            method_key = 'image'
            cooldown = method_cooldowns.get(method_key, ALERT_CONFIG['cooldown_seconds'])
            last_time = self.method_last_alert_time[method_key].get(alert_key, 0)
            
            if now - last_time >= cooldown:
                try:
                    # 파일명 생성
                    if alert_type == 'action':
                        filename = f"{timestamp}_{alert_type}_{action_type}.jpg"
                    elif alert_type == 'danger_zone':
                        filename = f"{timestamp}_{alert_type}_zone{zone_idx+1}.jpg"
                    else:
                        filename = f"{timestamp}_alert.jpg"
                    
                    # 이미지 저장
                    image_path = os.path.join(self.alert_image_dir, filename)
                    cv2.imwrite(image_path, frame)
                    logger.info(f"알림 이미지 저장: {image_path}")
                    self.method_last_alert_time[method_key][alert_key] = now
                except Exception as e:
                    logger.error(f"알림 이미지 저장 실패: {e}")
                
        # 이메일 알림
        if 'email' in ALERT_CONFIG['alert_methods']:
            method_key = 'email'
            cooldown = method_cooldowns.get(method_key, ALERT_CONFIG['cooldown_seconds'])
            last_time = self.method_last_alert_time[method_key].get(alert_key, 0)
            
            if now - last_time >= cooldown:
                self._send_email_alert(alert_msg)
                self.method_last_alert_time[method_key][alert_key] = now
            
        # API 알림
        if 'api' in ALERT_CONFIG['alert_methods']:
            method_key = 'api'
            cooldown = method_cooldowns.get(method_key, ALERT_CONFIG['cooldown_seconds'])
            last_time = self.method_last_alert_time[method_key].get(alert_key, 0)
            
            if now - last_time >= cooldown:
                self._send_api_alert('danger_zone', 1.0, alert_msg)
                self.method_last_alert_time[method_key][alert_key] = now

    def _send_email_alert(self, message):
        """
        이메일 알림 전송
        
        Args:
            message (str): 알림 메시지
        """
        try:
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            
            email_config = ALERT_CONFIG['email_config']
            
            msg = MIMEMultipart()
            msg['From'] = email_config['sender_email']
            msg['To'] = email_config['receiver_email']
            msg['Subject'] = '행동 패턴 분석 시스템 경고'
            
            msg.attach(MIMEText(message, 'plain'))
            
            server = smtplib.SMTP(email_config['smtp_server'], email_config['smtp_port'])
            server.starttls()
            server.login(email_config['sender_email'], email_config['password'])
            server.send_message(msg)
            server.quit()
            
            logger.info("이메일 알림 전송 성공")
            
        except Exception as e:
            logger.error(f"이메일 알림 전송 실패: {e}")
            
    def _send_api_alert(self, action_label, confidence, message=None):
        """
        API 알림 전송 (메시지 인자 추가)
        
        Args:
            action_label (str): 행동 라벨
            confidence (float): 신뢰도
            message (str, optional): 사용자 정의 메시지
        """
        try:
            import requests
            import json
            
            api_config = ALERT_CONFIG['api_config']
            
            payload = {
                'timestamp': time.time(),
                'action': action_label,
                'confidence': confidence,
                'message': message or f"{action_label} 행동 감지됨"
            }
            
            headers = api_config['headers']
            headers['Authorization'] = f"Bearer {api_config['auth_token']}"
            
            response = requests.post(
                api_config['url'],
                data=json.dumps(payload),
                headers=headers
            )
            
            if response.status_code == 200:
                logger.info("API 알림 전송 성공")
            else:
                logger.error(f"API 알림 전송 실패: {response.status_code}, {response.text}")
                
        except Exception as e:
            logger.error(f"API 알림 전송 실패: {e}")

    def _send_alert(self, action_label, confidence, frame=None):
        """
        행동 기반 알림 전송
        
        Args:
            action_label (str): 행동 라벨
            confidence (float): 신뢰도
            frame (numpy.ndarray, optional): 현재 비디오 프레임
        """
        alert_msg = f"[경고] {action_label} 행동 감지됨 (신뢰도: {confidence:.2f})"
        self._send_custom_alert(
            alert_msg,
            alert_type='action',
            action_type=action_label,
            frame=frame
        )


def parse_arguments():
    """명령행 인수 파싱"""
    parser = argparse.ArgumentParser(description='행동 패턴 분석 시스템')
    
    parser.add_argument(
        '--input', type=str,
        help='입력 소스 (파일 경로, 카메라 ID, RTSP URL, 이미지 폴더 경로)'
    )
    
    parser.add_argument(
        '--type', type=str, choices=['file', 'camera', 'rtsp', 'image_folder'],
        help='입력 소스 타입 (file, camera, rtsp, image_folder)'
    )
    
    parser.add_argument(
        '--image_pattern', type=str,
        help='이미지 파일 패턴 (예: *.jpg, frame_*.png)'
    )
    
    parser.add_argument(
        '--output', type=str,
        help='출력 파일 경로'
    )
    
    parser.add_argument(
        '--display', action='store_true',
        help='결과 실시간 표시 여부'
    )
    
    parser.add_argument(
        '--detector', type=str, choices=['yolov5', 'yolov8'],
        help='객체 검출기 유형'
    )
    
    parser.add_argument(
        '--pose_estimator', type=str, choices=['mediapipe'],
        help='자세 추정기 유형'
    )
    
    parser.add_argument(
        '--action_recognizer', type=str, choices=['rule', 'lstm'],
        help='행동 인식기 유형'
    )
    
    parser.add_argument(
        '--high_performance', action='store_true',
        help='고성능 모드 활성화 (더 많은 프레임 건너뛰기)'
    )
    
    parser.add_argument(
        '--window_size', type=str,
        help='창 크기 설정 (예: 1280x720)'
    )
    
    # FPS 제한 옵션 추가
    parser.add_argument(
        '--target_fps', type=int,
        help='목표 FPS 설정 (기본값: 30)'
    )
    
    # 프레임 크기 조정 옵션 추가
    parser.add_argument(
        '--frame_resize_factor', type=float,
        help='프레임 크기 조정 비율 (1.0: 원본 크기, 0.5: 반으로 축소)'
    )
    
    # 객체 탐지 신뢰도 임계값 설정 옵션 추가
    parser.add_argument(
        '--confidence_threshold', type=float,
        help='객체 탐지 신뢰도 임계값 (기본값: 0.5)'
    )
    
    return parser.parse_args()


def update_config_from_args(args):
    """
    명령행 인수로부터 설정 업데이트
    
    Args:
        args: 명령행 인수
    """
    # 비디오 입력 설정 업데이트
    if args.type:
        VIDEO_CONFIG['source_type'] = args.type
        
    if args.input:
        if args.type == 'file':
            VIDEO_CONFIG['source_path'] = args.input
            
            # 비디오 파일 프레임 크기 직접 확인하여 업데이트
            try:
                cap = cv2.VideoCapture(args.input)
                if cap.isOpened():
                    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                    
                    # config에서 자동 업데이트가 활성화되어 있는 경우에만 업데이트
                    if VIDEO_CONFIG.get('override_from_source', True):
                        VIDEO_CONFIG['frame_width'] = width
                        VIDEO_CONFIG['frame_height'] = height
                    
                    logger.info(f"비디오 파일 크기를 감지: {width}x{height}")
                cap.release()
            except Exception as e:
                logger.error(f"비디오 파일 크기 확인 중 오류: {e}")
                
        elif args.type == 'camera':
            VIDEO_CONFIG['camera_id'] = int(args.input)
        elif args.type == 'rtsp':
            VIDEO_CONFIG['rtsp_url'] = args.input
        elif args.type == 'image_folder':
            VIDEO_CONFIG['image_folder'] = args.input
            
            # 첫 번째 이미지 크기 확인하여 업데이트
            try:
                if args.image_pattern:
                    pattern = args.image_pattern
                else:
                    pattern = VIDEO_CONFIG['image_pattern']
                    
                import glob
                image_files = sorted(glob.glob(os.path.join(args.input, pattern)))
                if image_files:
                    first_image = cv2.imread(image_files[0])
                    if first_image is not None:
                        height, width = first_image.shape[:2]
                        
                        # config에서 자동 업데이트가 활성화되어 있는 경우에만 업데이트
                        if VIDEO_CONFIG.get('override_from_source', True):
                            VIDEO_CONFIG['frame_width'] = width
                            VIDEO_CONFIG['frame_height'] = height
                        
                        logger.info(f"이미지 파일 크기를 감지: {width}x{height}")
            except Exception as e:
                logger.error(f"이미지 파일 크기 확인 중 오류: {e}")
            
    # 이미지 파일 패턴 설정
    if args.image_pattern:
        VIDEO_CONFIG['image_pattern'] = args.image_pattern
            
    # 출력 파일 경로 설정
    if args.output:
        VISUALIZATION_CONFIG['output_path'] = args.output
        
    # 실시간 표시 설정
    if args.display:
        VISUALIZATION_CONFIG['display'] = True
        
    # 객체 검출기 설정
    if args.detector:
        DETECTION_CONFIG['model_type'] = args.detector
        
    # 자세 추정기 설정
    if args.pose_estimator:
        POSE_CONFIG['model_type'] = args.pose_estimator
        
    # 행동 인식기 설정
    if args.action_recognizer:
        ACTION_CONFIG['model_type'] = args.action_recognizer
    
    # 고성능 모드 설정
    if args.high_performance:
        VIDEO_CONFIG['skip_frames'] = 8  # 더 많은 프레임 건너뛰기 (6에서 8로 증가)
        VIDEO_CONFIG['performance_mode'] = 'high_speed'
        logger.info("고성능 모드가 활성화되었습니다. 더 많은 프레임을 건너뛰어 처리합니다.")
    else:
        # 고성능 모드가 아닌 경우, 기본 프레임 건너뛰기 수 증가 (객체 탐지 속도 개선)
        VIDEO_CONFIG['skip_frames'] = 4  # 기본값 증가 (3에서 4로 증가)
    
    # 프레임 크기 조정 설정
    if args.frame_resize_factor:
        SYSTEM_CONFIG['frame_resize_factor'] = args.frame_resize_factor
        logger.info(f"프레임 크기 조정 비율을 {args.frame_resize_factor}로 설정했습니다.")
    
    # 객체 탐지 신뢰도 임계값 설정
    if args.confidence_threshold:
        DETECTION_CONFIG['confidence_threshold'] = args.confidence_threshold
        logger.info(f"객체 탐지 신뢰도 임계값을 {args.confidence_threshold}로 설정했습니다.")
    
    # 창 크기 설정
    if args.window_size:
        try:
            width, height = map(int, args.window_size.split('x'))
            VIDEO_CONFIG['initial_window_width'] = width
            VIDEO_CONFIG['initial_window_height'] = height
            logger.info(f"창 크기를 {width}x{height}로 설정합니다.")
        except ValueError:
            logger.warning(f"잘못된 창 크기 형식: {args.window_size}, 형식은 '너비x높이'여야 합니다.")
        
    logger.debug(f"현재 비디오 프레임 크기: {VIDEO_CONFIG['frame_width']}x{VIDEO_CONFIG['frame_height']}")
    logger.debug(f"위험 구역 설정 이미지 크기: {DANGER_ZONE_CONFIG.get('original_frame_width')}x{DANGER_ZONE_CONFIG.get('original_frame_height')}")
    
    # 스케일링 설정 정보 로깅
    if VIDEO_CONFIG.get('scale_coordinates', True):
        scaling_ratio_w = VIDEO_CONFIG['frame_width'] / DANGER_ZONE_CONFIG.get('original_frame_width', VIDEO_CONFIG['frame_width'])
        scaling_ratio_h = VIDEO_CONFIG['frame_height'] / DANGER_ZONE_CONFIG.get('original_frame_height', VIDEO_CONFIG['frame_height'])
        logger.debug(f"좌표 자동 스케일링: 활성화, 비율 - 가로: {scaling_ratio_w:.4f}, 세로: {scaling_ratio_h:.4f}")
    else:
        logger.debug("좌표 자동 스케일링: 비활성화")


def main():
    """메인 함수"""
    # 명령행 인수 파싱
    args = parse_arguments()
    
    # 목표 FPS 설정
    if args.target_fps:
        SYSTEM_CONFIG['target_fps'] = args.target_fps
        logger.info(f"목표 FPS를 {args.target_fps}로 설정했습니다.")
    
    # 프레임 크기 조정 설정
    if args.frame_resize_factor:
        SYSTEM_CONFIG['frame_resize_factor'] = args.frame_resize_factor
        logger.info(f"프레임 크기 조정 비율을 {args.frame_resize_factor}로 설정했습니다.")
    
    # 객체 탐지 신뢰도 임계값 설정
    if args.confidence_threshold:
        DETECTION_CONFIG['confidence_threshold'] = args.confidence_threshold
        logger.info(f"객체 탐지 신뢰도 임계값을 {args.confidence_threshold}로 설정했습니다.")
    
    # 설정 업데이트
    update_config_from_args(args)
    
    # 시스템 초기화
    system = BehaviorAnalysisSystem()
    if not system.initialize():
        logger.error("시스템 초기화 실패")
        return
    
    # Ctrl+C 핸들러 설정
    def signal_handler(sig, frame):
        logger.info("Ctrl+C가 감지되었습니다. 프로그램을 종료합니다...")
        system.running = False  # 시스템 종료 플래그 설정
        
    # SIGINT 신호 핸들러 등록
    signal.signal(signal.SIGINT, signal_handler)
        
    # 비디오 처리
    system.process_video()
    
    logger.info("프로그램 종료")
    

if __name__ == "__main__":
    main() 